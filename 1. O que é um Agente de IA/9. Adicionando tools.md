# Resumo da Aula ‚Äì Implementando a Primeira Ferramenta (Function Calling)

## Objetivo
Ensinar o Gemini a **usar ferramentas** para responder perguntas que ele n√£o conseguiria acertar sozinho (ex.: "Que dia √© hoje?").

## Problema inicial
- Chamada simples √† API do Gemini ‚Üí responde datas aleat√≥rias e erradas  
  - Ex.: "S√°bado, 15 de junho de 2024" (muda a cada execu√ß√£o)  
- Motivo: o modelo n√£o tem acesso ao mundo externo ‚Üí s√≥ gera texto plaus√≠vel com base no treinamento

## Solu√ß√£o: Declarar uma ferramenta (function declaration)
Na configura√ß√£o da chamada ao Gemini, passamos um objeto `tools` com `functionDeclarations`:

```js
tools: [
  {
    functionDeclarations: [
      {
        name: "getTodayDate",
        description: "Retorna a data de hoje no formato internacional (YYYY-MM-DD).",
        parameters: { ... } // ainda sem par√¢metros neste exemplo
      }
    ]
  }
]
```

- **Importante**: s√≥ declaramos a fun√ß√£o (nome + descri√ß√£o)  
- N√£o implementamos o c√≥digo ainda  
- A descri√ß√£o √© essencial: a IA usa ela para decidir quando chamar a fun√ß√£o

## Fluxo completo de function calling (modo manual ‚Äì JS)

1. **Usu√°rio pergunta**: "Que dia √© hoje?"  
2. **Gemini responde** com uma **function call**:  
   - Indica que quer chamar `getTodayDate`  
   - Sem argumentos (pois a fun√ß√£o n√£o precisa de nenhum)  
3. **N√≥s (c√≥digo) executamos** a fun√ß√£o real e obtemos o resultado (ex.: "2025-04-01")  
4. **Devolvemos o resultado** para o Gemini como uma mensagem especial:  
   ```js
   {
     role: "user",
     parts: [
       {
         functionResponse: {
           name: "getTodayDate",
           response: { result: "2025-04-01" }
         }
       }
     ]
   }
   ```
5. **Gemini recebe o resultado** e finalmente responde corretamente:  
   - "Hoje √© 1¬∫ de Abril de 2025"  
   - Teste alterando o resultado ‚Üí a resposta da IA muda conforme o valor retornado

## Tipos de function calling (par√™nteses do professor)
1. **Autom√°tico** (IA executa a fun√ß√£o sozinha)  
   - Dispon√≠vel apenas na API Python do Google Generative AI  
   - Ainda n√£o implementado em JavaScript  
2. **Manual** (o que estamos fazendo)  
   - N√≥s controlamos a execu√ß√£o da fun√ß√£o  
   - Mais educativo e d√° maior controle  
3. **IA cria e executa a fun√ß√£o do zero**  
   - Muito propenso a erros ‚Üí professor n√£o recomenda

## Como o hist√≥rico da conversa √© mantido
- Usamos um array `contents` que vai crescendo:  
  1. Mensagem do usu√°rio  
  2. Resposta do model com function call  
  3. Mensagem do usu√°rio com function response (resultado)  
  4. Nova chamada ao model ‚Üí resposta final  

## O que vimos na resposta da IA
- Quando quer usar ferramenta ‚Üí retorna `functionCall` dentro de `parts`  
  - Cont√©m: `name` da fun√ß√£o e `args` (argumentos, vazio neste caso)  
- Isso ser√° essencial para as pr√≥ximas fun√ß√µes (com par√¢metros)

## Pr√≥ximo passo
- Implementar **fun√ß√µes com argumentos**  
- Criar l√≥gica para **detectar dinamicamente** qual fun√ß√£o foi solicitada (usando o `name` retornado)  
- Parar de hardcodar a chamada e come√ßar a usar um sistema real de ferramentas

Agora a secret√°ria j√° sabe pedir ajuda para saber a data atual! Pr√≥xima etapa: fun√ß√µes mais complexas com par√¢metros. üöÄ