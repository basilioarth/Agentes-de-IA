## Estruturação de um grafo multiagente com supervisor e especialistas

### Objetivo da aula

Nesta aula, o professor evolui o grafo para **representar um sistema de multiagentes de fato**, introduzindo:

* Um **Supervisor** (orquestrador).
* Três **especialistas**:

  * Financial Specialist.
  * Scheduling Specialist.
  * Comms (ou Messaging) Specialist.

O foco é **modelar o fluxo de controle entre esses agentes**, não ainda a inteligência deles.

---

### Transformação do nó principal em Supervisor

* O nó anteriormente chamado de `Mateus` passa a ser o **Supervisor**.
* O fluxo inicial fica:

  * `Start → Supervisor → End`.
* A execução é validada apenas para garantir que a estrutura continua funcionando.

---

### Criação dos nós especialistas

* São adicionados três novos nós ao grafo:

  * Financial Specialist.
  * Scheduling Specialist.
  * Comms Specialist.
* Todos usam, inicialmente, **ações mock**, pois o objetivo é apenas visualizar e controlar o fluxo.
* Nesse momento, os especialistas ainda não estão conectados ao Supervisor.

---

### Conexão inicial e problema de paralelismo

* O Supervisor é conectado diretamente a todos os especialistas.
* Isso faz com que:

  * Todos os especialistas sejam executados **em paralelo**.
  * O `End` também seja acionado ao mesmo tempo.
* O professor comprova isso observando:

  * O contador de nós executados.
  * Logs que mostram múltiplas execuções ocorrendo simultaneamente.
* Esse comportamento **não é desejado**, pois o sistema precisa executar os agentes **em sequência**, não em paralelo.

---

### Introdução às arestas condicionais

* Para resolver o paralelismo, o professor apresenta as **arestas condicionais**.
* Em vez de usar `addEdge`, passa-se a usar `addConditionalEdges`.
* Nessas arestas:

  * O destino não é fixo.
  * Uma função decide **qual nó será executado com base no estado**.
* Visualmente, essas arestas aparecem como **pontilhadas**, indicando decisão condicional.

---

### Primeira decisão condicional

* O Supervisor passa a decidir, de forma simples e fixa, qual especialista chamar.
* Inicialmente:

  * Sempre retorna o Financial Specialist.
* Resultado:

  * Apenas o Supervisor e o Financial Specialist são executados.
  * Confirma-se que a lógica condicional está funcionando.

---

### Retorno dos especialistas ao Supervisor

* Para permitir múltiplas decisões:

  * Cada especialista é conectado de volta ao Supervisor.
* Isso cria um **loop Supervisor → Especialista → Supervisor**.
* Porém, isso gera um **loop infinito**, já que não existe ainda uma condição de parada.

---

### Uso do estado para controlar o fluxo

* Para evitar loops infinitos:

  * O Supervisor passa a usar o campo `executedNodes` do estado.
* A lógica implementada:

  * Dependendo do número de nós já executados:

    * Chama um especialista específico.
    * Ou encerra o fluxo indo para o `End`.

---

### Execução sequencial dos especialistas

* A lógica final do Supervisor segue este padrão:

  * Se poucos nós foram executados → chama Financial Specialist.
  * Depois → chama Scheduling Specialist.
  * Depois → chama Comms Specialist.
  * Após isso → vai para o End.
* Cada especialista:

  * Executa sua ação mock.
  * Retorna obrigatoriamente para o Supervisor.
* Assim, o fluxo se torna **sequencial e controlado**, e não mais paralelo.

---

### Validação do fluxo

* O professor executa o grafo e acompanha o caminho percorrido:

  * Supervisor → Financial → Supervisor.
  * Supervisor → Scheduling → Supervisor.
  * Supervisor → Comms → Supervisor.
  * Supervisor → End.
* Apesar de pequenos ajustes ainda necessários, o **modelo conceitual do grafo está correto**.

---

### Estado atual do sistema

* O grafo agora possui:

  * Um Supervisor orquestrando decisões.
  * Especialistas que executam ações e retornam controle.
  * Um fluxo sequencial controlado por estado.
* As ações ainda são mockadas, sem inteligência real.

---

### Próximos passos

* Tornar o **Supervisor inteligente**, usando IA para decidir qual especialista chamar.
* Implementar comportamentos reais nos especialistas.
* Possivelmente adicionar:

  * Um nó de interface com o usuário (chat).
  * Comunicação direta entre usuário e Supervisor.
* A partir daqui, o foco deixa de ser apenas estrutura e passa a ser **inteligência e interação real**.
