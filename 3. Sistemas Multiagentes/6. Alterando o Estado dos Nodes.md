## Evolução do estado no LangGraph com reducers e mensagens estruturadas

### Objetivo da aula

O foco desta aula é **tornar o estado do grafo mais útil e controlável**, evitando a sobrescrita constante de valores. O professor mostra como evoluir o estado para **acumular informações**, algo essencial para sistemas multiagentes.

---

### Introdução ao conceito de reducer

* É introduzido o conceito de **reducer**, comum em programação funcional.
* Um reducer recebe:

  * O **valor atual** do estado.
  * O **novo valor**.
* A partir disso, retorna **um único valor resultante**.
* Até então, o comportamento padrão era:

  * Descartar o valor atual e sobrescrever com o novo.
* Com reducers explícitos, esse comportamento pode ser alterado.

---

### Controle da sobrescrita de estado

* O professor demonstra que:

  * É possível manter sempre o valor atual.
  * Ou concatenar o valor atual com o novo.
* Esse controle permite decidir **como o estado evolui** ao longo da execução do grafo.

---

### Transformação do output em lista

* Para permitir o acúmulo de informações:

  * O `output` deixa de ser uma string simples.
  * Passa a ser **um array**.
* O reducer do `output` passa a:

  * Concatenar o valor atual com o novo valor.
* Isso permite que cada nó **adicione informações**, em vez de sobrescrevê-las.

---

### Valor padrão (default) no estado

* É discutido o problema do estado inicial não possuir `output`.
* O professor observa que o `Annotation` já inicializa automaticamente com valores vazios.
* Ainda assim, é apresentado o uso de `default` para:

  * Definir explicitamente o valor inicial do estado.
  * Controlar melhor o comportamento inicial do grafo.
* Exemplo de uso:

  * Um `output` inicial como `"Olá"` pode ser definido.

---

### Evolução para mensagens estruturadas

* O professor lembra que modelos de IA seguem um **protocolo de mensagens**, geralmente composto por:

  * `role` (quem fala: usuário ou IA).
  * `content` (a mensagem em si).
* Em vez de trabalhar com strings, o LangGraph já oferece uma abstração pronta:

  * `BaseMessage`.
* O `output` passa a ser:

  * Uma lista de `BaseMessage`.

---

### Tipos de mensagens

* São apresentados os principais tipos:

  * `AIMessage`: representa mensagens geradas pela IA.
  * `HumanMessage`: representa mensagens do usuário.
* A diferença entre eles é identificar **quem produziu a mensagem**.
* O reducer continua concatenando mensagens, mas agora:

  * Concatena objetos estruturados, não strings.

---

### Benefícios do uso de BaseMessage

* O estado passa a seguir o **formato esperado pelas IAs**.
* Facilita a integração com o SDK do LangGraph para modelos como o Gemini.
* O fluxo passa a ser:

  * Enviar `HumanMessage` para a IA.
  * Receber `AIMessage` como resposta.
* Isso elimina a necessidade de adaptar mensagens manualmente no futuro.

---

### Padronização do input

* O `input` do estado também pode ser convertido em `HumanMessage`.
* Assim, todo o grafo trabalha com um **padrão único de mensagens**.

---

### Adição de métricas ao estado

* O professor mostra que o estado pode armazenar **informações adicionais**, como métricas.
* Exemplo:

  * `executedNodes`: número de nós executados.
* Esse campo:

  * Usa um reducer que incrementa o valor.
  * Começa com `default = 0`.
* Cada nó executado incrementa esse contador.
* No exemplo, o valor final indica que dois nós foram executados.

---

### Estado final e próximos passos

* O estado agora está mais robusto, contendo:

  * Mensagens acumuladas.
  * Entrada padronizada.
  * Métricas de execução.
* Algumas partes serão usadas intensivamente (mensagens).
* Outras são apenas demonstrativas (contador de nós).
* O professor encerra indicando que:

  * O grafo ainda está muito simples.
  * Novos nós serão adicionados.
  * A estrutura será expandida para suportar **multiagentes reais** nas próximas aulas.
