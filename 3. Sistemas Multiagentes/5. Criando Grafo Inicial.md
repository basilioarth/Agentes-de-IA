## Construção de um grafo de agentes com LangGraph

### Objetivo da aula

O professor inicia a aula explicando que o objetivo é **construir um sistema de multiagentes passo a passo**, com bastante cuidado, devido à complexidade envolvida. A ideia inicial não é criar agentes complexos, mas **montar um grafo funcional** para visualizar o fluxo de execução e entender os conceitos fundamentais.

---

### Configuração inicial do projeto

* Criação de um projeto Node.js vazio.
* Inicialização do projeto com `npm init`.
* Inicialização do TypeScript com `tsc --init`.
* Ajustes no `tsconfig`:

  * `target` configurado para **ES2022**.
  * `module` e `moduleResolution` configurados como **node-next**.
* Criação do arquivo `index.ts` como ponto de entrada do projeto.

---

### Instalação e contexto do LangGraph

* Instalação da biblioteca necessária:

  * `lang-graph-core`.
* O professor explica que o **LangGraph ainda não está na versão 1.0**, estando em desenvolvimento.
* A versão 1.0 Alpha já utiliza **Zod**, mas ainda apresenta instabilidades.
* Por isso, a aula utiliza a versão anterior, que trabalha com **Annotation**, uma abordagem semelhante ao Zod para definição de esquemas.

---

### Definição do estado do grafo

* O **estado** é o elemento central do grafo, responsável por carregar as informações entre os nós.
* O estado é definido com `Annotation` e possui:

  * `input`: uma string que representa a entrada inicial do grafo.
  * `output`: uma string que representa o resultado produzido pelos nós.
* Inicialmente, o estado é simples, mas o professor avisa que ele ficará mais complexo ao longo das próximas aulas.

---

### Criação do State Graph

* Importação do `StateGraph`.
* Criação de uma instância do grafo passando o estado como parâmetro.
* O grafo, nesse momento, está vazio e serve apenas como estrutura de comunicação entre os nós.

---

### Criação do primeiro nó

* Uso do método `addNode` para adicionar um nó ao grafo.
* Cada nó recebe:

  * Um **nome** (ex.: `Mateus`).
  * Uma **função** que define o comportamento do nó.
* A função (mock) recebe o estado atual e retorna um objeto que **altera o estado**.
* No exemplo, o nó sobrescreve o `output` com a mensagem `"Mateus disse oi"`.

---

### Nós especiais: Start e End

* O grafo possui dois nós especiais:

  * **Start**: ponto inicial do fluxo, não recebe entradas.
  * **End**: ponto final do fluxo, não possui saídas.
* Esses nós já existem no grafo e não precisam ser declarados manualmente.
* O professor cria as conexões:

  * `Start → Mateus`
  * `Mateus → End`

---

### Compilação e execução do grafo

* O grafo é compilado para ficar pronto para execução.
* O método `invoke` é usado para executar o grafo, recebendo o **estado inicial**.
* O estado inicial contém apenas o `input` (ex.: `"Olá"`).
* Durante a execução:

  * O `input` entra pelo `Start`.
  * O nó `Mateus` modifica o `output`.
  * O `End` retorna o **estado final**.
* O resultado final do estado é exibido no console.

---

### Adição de um segundo nó

* Criação de um novo nó chamado `Juliana`.
* Definição de uma nova função mock que altera o `output` para `"Juliana disse oi"`.
* Atualização das conexões do grafo:

  * `Start → Mateus`
  * `Mateus → Juliana`
  * `Juliana → End`
* Ao executar o grafo, percebe-se que:

  * O nó `Juliana` sobrescreve o `output` definido pelo nó `Mateus`.

---

### Limitação do modelo atual de estado

* Para evitar sobrescrita, o professor testa a criação de múltiplos campos no estado (ex.: `outputMateus` e `outputJuliana`).
* Apesar de funcionar, essa abordagem não é ideal.
* O professor antecipa que o correto será trabalhar com **listas de mensagens**, onde cada nó apenas adiciona informações ao estado, em vez de sobrescrevê-las.
* Esse tema será aprofundado na próxima aula.

---

### Visualização do grafo

* O professor destaca que grafos são difíceis de visualizar apenas em código.
* O LangGraph permite gerar uma representação visual do grafo:

  * Uso de `getGraphAsync` para obter um objeto representando o grafo.
  * Conversão do grafo para uma imagem PNG usando **Mermaid**.
* O PNG gerado é convertido para `ArrayBuffer` e salvo em arquivo usando o `fs`.
* O resultado é uma imagem mostrando claramente:

  * `Start → Mateus → Juliana → End`.

---

### Encerramento e próximos passos

* O grafo criado é apenas estrutural e ainda não executa lógica real.
* Pontos que ainda precisam ser implementados:

  * Evitar sobrescrita de dados no estado.
  * Trabalhar com listas de mensagens.
  * Tornar o grafo não linear.
  * Criar um **agente orquestrador**.
  * Permitir que agentes utilizem **ferramentas**.
* O professor encerra a aula indicando que esses tópicos serão desenvolvidos nas próximas implementações.
