## Resumo da Aula — Agentes de IA: Expansão de Habilidades

Nesta aula, o professor avança na construção de um sistema de **agentes de IA orquestrados por um supervisor**, focando principalmente na **implementação prática das ferramentas (tools)** que cada agente utilizará. O objetivo é mostrar como estruturar um ecossistema de agentes especializados usando **LangGraph**, **CreateReactAgent** e **Dynamic Structured Tools**, mesmo que de forma simplificada (mockada).

---

## 1. Correções importantes da aula anterior

Antes de implementar novas ferramentas, o professor esclarece dois pontos fundamentais:

### 1.1 Funções sem parâmetros
- Para declarar uma função **sem parâmetros**, é obrigatório passar um `schema` como um **objeto vazio** (`z.object({})`).
- Tentar omitir o schema ou passá-lo de forma incorreta gera erro.

### 1.2 Problema com o campo `name`
- O uso do campo `name` na mensagem causou erro ao usar o **Gemini**.
- Nem todas as LLMs aceitam esse parâmetro.
- A solução adotada foi **incluir o nome do especialista diretamente no texto da resposta**, evitando o uso do `name` no objeto da mensagem.

---

## 2. Ferramentas do Financial Specialist

O professor implementa várias ferramentas para o **Financial Specialist**, todas mockadas, apenas para demonstrar o funcionamento.

### Ferramentas criadas:
- **payBill**  
  → Simula o pagamento de uma conta.

- **getBill**  
  → Retorna o valor atual da conta (exemplo fixo: R$ 500).

- **createBill**  
  → Cria um novo boleto com valor informado (exemplo: boleto gerado com sucesso).

Essas ferramentas são registradas no agente usando `DynamicStructuredTool`.

### Testes realizados:
- “Quero pagar minha conta”
- “Quero ver o valor da minha conta”
- “Quero gerar um novo boleto”

O agente consegue identificar corretamente as intenções mais simples, mas em alguns casos não escolhe a ferramenta esperada, o que é aceito pelo professor por se tratar apenas de um exemplo.

---

## 3. Criação do Scheduling Specialist

Em seguida, o professor cria o **Scheduling Specialist**, responsável pela agenda do consultório.

### Prompt do agente:
- Atua como **secretário do consultório**
- Responsável por **organizar a agenda**
- Analisa a conversa e toma a melhor ação

### Ferramentas implementadas:
- **scheduleAppointment** → Marca consulta
- **rescheduleAppointment** → Remarca consulta
- **cancelAppointment** → Cancela consulta

Todas as funções:
- Não recebem parâmetros
- Retornam mensagens fixas de sucesso

### Problema encontrado:
- O agente entra em **loop infinito**, chamando ferramentas repetidamente.
- Isso acontece porque:
  - O prompt permite raciocinar indefinidamente
  - Não há controle explícito de encerramento
- O LangGraph interrompe após atingir o limite de recursão (25).

### Ajuste temporário:
- O professor altera o prompt para dizer que:
  - O agente **não precisa de informações adicionais**
  - Não deve fazer perguntas
  - Deve apenas executar a ação diretamente

---

## 4. Criação do Comms (Communication) Specialist

O **Comms Specialist** é responsável apenas por **comunicar o resultado final ao usuário**.

### Função criada:
- **sendEmail**
  - Recebe `emailContent` (string)
  - Simula envio de e-mail com `console.log`
  - Retorna “e-mail enviado com sucesso”

### Prompt do agente:
- Resume toda a conversa
- Resume todas as ações executadas
- Envia um e-mail para o cliente
- Não deve pedir confirmação

---

## 5. Ajustes no Supervisor

O **Supervisor** recebe um novo papel:
- Redirecionar mensagens para os especialistas corretos
- **Ao final de tudo**, chamar obrigatoriamente o **Comms Specialist**
- Depois disso, **encerrar o fluxo**

### Problemas observados:
- O Supervisor entra em loop chamando repetidamente o Comms Specialist
- O Comms Specialist tenta confirmar ações (“Deseja que eu envie o e-mail?”), mesmo sendo instruído a não perguntar

### Debug aplicado:
- Uso de `console.log` para inspecionar:
  - Respostas dos agentes
  - Histórico de mensagens
- Isso ajuda a entender por que o fluxo não está encerrando corretamente

---

## 6. Lições importantes da aula

- **Agentes podem entrar facilmente em loop** se:
  - O prompt não for extremamente explícito
  - Não houver controle rígido de encerramento
- **Nem sempre dá para confiar 100% no comportamento da LLM**
- O LangGraph permite:
  - Forçar caminhos no grafo
  - Reduzir autonomia quando necessário
- Em sistemas reais, é essencial:
  - Definir claramente entradas e saídas
  - Controlar quando o fluxo deve terminar
  - Limitar responsabilidades de cada agente

---

## 7. Encerramento

O professor encerra a aula destacando que:
- Todas as ferramentas principais já foram implementadas
- O sistema está funcional, mas precisa de **ajustes finos**
- O próximo vídeo será dedicado a:
  - Corrigir loops
  - Forçar chamadas de ferramentas
  - Refinar o fluxo final até o encerramento correto

A aula teve foco **prático**, priorizando entendimento arquitetural e comportamento dos agentes, e não a perfeição do código.

---
