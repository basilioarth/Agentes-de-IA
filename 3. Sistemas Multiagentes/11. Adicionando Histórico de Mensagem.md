## Tornando o Supervisor realmente inteligente com histórico de conversa

### Objetivo do vídeo

O objetivo desta etapa é fazer com que o **Supervisor tome decisões baseadas no histórico da conversa**, e não mais em prompts fixos. Assim, ele consegue entender a intenção do usuário e escolher corretamente qual especialista chamar a cada momento.

---

### Problema do modelo anterior

* O Supervisor:

  * Escolhia o próximo nó sem contexto.
  * Não sabia **o que o usuário já tinha pedido**.
* Exemplo:

  * “Quero ver minha nota fiscal” → deveria chamar o **Financial Specialist**.
  * “Quero marcar uma consulta” → deveria chamar o **Scheduling Specialist**.
* Para isso, o Supervisor precisa:

  * Ter acesso ao **histórico completo de mensagens**.

---

### Mudança no `state`

* O estado do grafo é simplificado:

  * Remove-se `executedNodes`.
  * Remove-se separação entre `input` e `output`.
* Novo formato do estado:

  * `messages`: lista de mensagens (histórico da conversa).
* Esse array de mensagens será:

  * Passado diretamente para a IA.
  * Usado como contexto para decisão.

---

### Uso do `ChatPromptTemplate`

* Para combinar:

  * Instruções fixas (prompt do sistema).
  * Histórico da conversa.
  * Pedido explícito de decisão.
* É utilizado o **`ChatPromptTemplate.fromMessages`**.

---

### Estrutura do prompt do Supervisor

O prompt é composto por três partes:

1. **Mensagem do sistema**

   * Define o papel da IA:

     * “Você é o supervisor de um consultório”.
     * Deve tomar a melhor decisão com base na conversa.

2. **Histórico da conversa**

   * Inserido via `MessagesPlaceholder`.
   * Recebe dinamicamente o `state.messages`.

3. **Mensagem final (humano)**

   * Instrução clara:

     * “Escolha um dos próximos estados”.
   * Lista explícita de opções:

     * Financial Specialist
     * Scheduling Specialist
     * Comms Specialist
     * End (estado terminal, se não houver mais nada a fazer)

---

### Uso do `MessagesPlaceholder`

* O `MessagesPlaceholder`:

  * Marca o local onde o histórico será injetado.
  * Converte automaticamente as mensagens para o formato esperado pela IA.
* O nome do placeholder deve:

  * Coincidir com a chave passada no `invoke` (`messages`).

---

### Encadeamento com `pipe`

* O prompt é encadeado com a IA usando:

  * `prompt.pipe(AIWithTool)`
* O Supervisor passa a:

  * Invocar o **prompt encadeado**, não a IA diretamente.
* A chamada é feita com:

  * `{ messages: state.messages }`.

---

### Fluxo completo após a mudança

1. O grafo inicia com uma mensagem do usuário (ex: “Olá”).
2. O Supervisor:

   * Lê o prompt do sistema.
   * Recebe o histórico via `MessagesPlaceholder`.
   * Solicita a escolha do próximo estado.
3. A IA:

   * Usa a `RoutingTool`.
   * Decide qual nó executar.
4. O grafo segue para o especialista escolhido.

---

### Ajustes nos especialistas

* Os especialistas agora:

  * Devem **adicionar mensagens ao histórico**.
* Exemplo no Financial Specialist:

  * Retorno: “Aqui está sua conta: R$300”.

---

### Bug encontrado: tipo da mensagem

* Problema:

  * O Supervisor entrava em loop.
* Causa:

  * A resposta do especialista estava sendo adicionada como **AIMessage**.
  * A IA entendia que era ela mesma falando.
* Solução:

  * Trocar para **HumanMessage**.
* Resultado:

  * A IA passa a entender que:

    * O especialista “falou com o usuário”.
    * Agora é hora de decidir o próximo passo.

---

### Resultado final

* O Supervisor agora:

  * Decide com base no **histórico da conversa**.
  * Chama especialistas coerentes com a intenção do usuário.
  * Encerra corretamente quando não há mais ações (`End`).
* O sistema deixa de ser apenas técnico e passa a:

  * Simular uma **conversa real com múltiplos agentes**.

---

### Observação importante

* Esse tipo de erro (AIMessage vs HumanMessage):

  * É comum.
  * Pode travar o fluxo por muito tempo se não for entendido.
* Faz parte dos detalhes práticos de implementação em sistemas multiagentes.

---

### Próximo passo anunciado

* Evoluir os especialistas para:

  * Executarem ações reais.
  * Manterem a conversa fluindo.
* Construir um sistema multiagente que:

  * Atua em sequência.
  * Entende contexto.
  * Resolve problemas reais do usuário.
